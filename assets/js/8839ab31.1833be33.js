/*! For license information please see 8839ab31.1833be33.js.LICENSE.txt */
"use strict";(self.webpackChunk_baeta_website=self.webpackChunk_baeta_website||[]).push([[6598],{6695:(e,r,i)=>{i.r(r),i.d(r,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>a,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"directives","title":"Directives","description":"Directives in Baeta allow you to modify the execution behavior of your GraphQL schema. They can be applied to various parts of your schema and provide a way to add metadata or transform data.","source":"@site/docs/directives.mdx","sourceDirName":".","slug":"/directives","permalink":"/docs/directives","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":120,"frontMatter":{"sidebar_position":120},"sidebar":"defaultSidebar","previous":{"title":"Interfaces & Unions","permalink":"/docs/interfaces-unions"},"next":{"title":"Input Directives","permalink":"/docs/input-directives"}}');var n=i(7250),s=i(589);const a={sidebar_position:120},o="Directives",c={},d=[{value:"Defining a Directive",id:"defining-a-directive",level:2},{value:"Implementing Directive Logic",id:"implementing-directive-logic",level:2},{value:"Usage",id:"usage",level:2}];function l(e){const r={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(r.header,{children:(0,n.jsx)(r.h1,{id:"directives",children:"Directives"})}),"\n",(0,n.jsx)(r.p,{children:"Directives in Baeta allow you to modify the execution behavior of your GraphQL schema. They can be applied to various parts of your schema and provide a way to add metadata or transform data."}),"\n",(0,n.jsx)(r.h2,{id:"defining-a-directive",children:"Defining a Directive"}),"\n",(0,n.jsx)(r.p,{children:(0,n.jsx)(r.code,{children:"src/modules/directives/directives.gql"})}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-graphql",children:"directive @upper on FIELD_DEFINITION\n\ntype NameWithUpper {\n  name: String! @upper\n}\n\ntype Query {\n  testUpperDirective(name: String!): NameWithUpper\n}\n"})}),"\n",(0,n.jsx)(r.h2,{id:"implementing-directive-logic",children:"Implementing Directive Logic"}),"\n",(0,n.jsxs)(r.p,{children:["To implement the directive's behavior, use the ",(0,n.jsx)(r.code,{children:"$directive"})," method:"]}),"\n",(0,n.jsx)(r.p,{children:(0,n.jsx)(r.code,{children:"src/modules/directives/directives.ts"})}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-typescript",children:"import { MapperKind, getDirective, mapSchema } from '@graphql-tools/utils';\nimport { defaultFieldResolver } from 'graphql';\nimport { getCustomNativeDirectiveModule } from './typedef';\n\nconst { $directive, Query } = getCustomNativeDirectiveModule();\n\n$directive((schema) => {\n  return mapSchema(schema, {\n    // Executes once for each object field in the schema\n    [MapperKind.OBJECT_FIELD]: (fieldConfig) => {\n      // Check whether this field has the specified directive\n      const upperDirective = getDirective(schema, fieldConfig, 'upper')?.[0];\n\n      if (!upperDirective) {\n        return fieldConfig;\n      }\n\n      // Get this field's original resolver\n      const { resolve = defaultFieldResolver } = fieldConfig;\n\n      // Replace the original resolver with a function that *first* calls\n      // the original resolver, then converts its result to upper case\n      fieldConfig.resolve = async (source, args, context, info) => {\n        const result = await resolve(source, args, context, info);\n        if (typeof result === 'string') {\n          return result.toUpperCase();\n        }\n        return result;\n      };\n      return fieldConfig;\n    },\n  });\n});\n\n// Implement the query resolver\nQuery.testUpperDirective(({ args }) => {\n  return {\n    name: args.name,\n  };\n});\n"})}),"\n",(0,n.jsxs)(r.p,{children:["This example creates an ",(0,n.jsx)(r.code,{children:"@upper"})," directive that converts string fields to uppercase. The directive is applied during schema creation and modifies the field's resolver to transform its output."]}),"\n",(0,n.jsx)(r.h2,{id:"usage",children:"Usage"}),"\n",(0,n.jsx)(r.p,{children:"When querying, the directive will automatically transform the result:"}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-graphql",children:'query {\n  testUpperDirective(name: "hello") {\n    name # Will return "HELLO"\n  }\n}\n'})}),"\n",(0,n.jsxs)(r.p,{children:["For more information on directives, see the ",(0,n.jsx)(r.a,{href:"https://graphql.org/learn/execution/#directives",children:"GraphQL documentation"})," and the ",(0,n.jsx)(r.a,{href:"https://github.com/andreisergiu98/baeta/tree/main/examples/directives",children:"Baeta directives example"}),"."]})]})}function p(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},2410:(e,r,i)=>{var t=i(7402),n=Symbol.for("react.element"),s=Symbol.for("react.fragment"),a=Object.prototype.hasOwnProperty,o=t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,c={key:!0,ref:!0,__self:!0,__source:!0};function d(e,r,i){var t,s={},d=null,l=null;for(t in void 0!==i&&(d=""+i),void 0!==r.key&&(d=""+r.key),void 0!==r.ref&&(l=r.ref),r)a.call(r,t)&&!c.hasOwnProperty(t)&&(s[t]=r[t]);if(e&&e.defaultProps)for(t in r=e.defaultProps)void 0===s[t]&&(s[t]=r[t]);return{$$typeof:n,type:e,key:d,ref:l,props:s,_owner:o.current}}r.Fragment=s,r.jsx=d,r.jsxs=d},7250:(e,r,i)=>{e.exports=i(2410)},589:(e,r,i)=>{i.d(r,{R:()=>a,x:()=>o});var t=i(7402);const n={},s=t.createContext(n);function a(e){const r=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function o(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:a(e.components),t.createElement(s.Provider,{value:r},e.children)}}}]);