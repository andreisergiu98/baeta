import tsconfig from '../../../tools/tsconfig/tsconfig.json';
import type { JavaScriptRuntime } from '../lib/constants.ts';
import type { TemplateFile } from '../lib/template-file.ts';
import dependenciesVersions from '../versions.json';

export type PackageJson = {
	name: string;
	scripts: Record<string, string | undefined>;
	dependencies: Record<string, string | undefined>;
	devDependencies: Record<string, string | undefined>;
};

export function makeSharedTemplate(
	appName: string,
	runtime: JavaScriptRuntime,
	packageJson: PackageJson,
): TemplateFile[] {
	return [
		makePackageJson(appName, runtime, packageJson),
		{
			relativePath: './tsconfig.json',
			content: JSON.stringify(
				{
					...tsconfig,
					compilerOptions: {
						...tsconfig.compilerOptions,
						rootDir: 'src',
						outDir: 'dist',
						noEmit: true,
						emitDeclarationOnly: false,
					},
					exclude: ['baeta.ts'],
				},
				null,
				2,
			),
		},
		{
			relativePath: './src/lib/extensions.ts',
			content: `import { createExtensions } from '@baeta/core';
import { complexityExtension } from '@baeta/extension-complexity';
import type { Context } from '../types/context.ts';

const complexity = complexityExtension<Context>({
	defaultComplexity: 1,
	defaultListMultiplier: 10,
	async limit(ctx) {
		return {
			depth: 10,
			breadth: 50,
			complexity: 1000,
		};
	},
});

export default createExtensions(complexity);
`,
		},
		{
			relativePath: './src/modules/user/user.gql',
			content: `type User {
	id: ID!
	email: String!
	lastName: String!
	profile: String
	givenName: String
}

input UserWhereUniqueInput {
	id: ID!
}

type Query {
	user(where: UserWhereUniqueInput!): User
	users: [User!]
}
`,
		},
		{
			relativePath: './src/modules/user/user.resolvers.ts',
			content: `import { getUserModule } from './typedef.ts';

const { Query } = getUserModule();

Query.user(({ args }) => {
	return {
		id: args.where.id,
		email: 'jon.doe@baeta.io',
		lastName: 'Doe',
	};
});

Query.user.$use(async ({ args }, next) => {
	const result = await next();
	console.log('Got user:', result, 'for args:', args);
	return result;
});

Query.users(() => {
	const users = Array.from({ length: 10 }).map((_, i) => ({
		id: i.toString(),
		email: \`jon.doe\${i}@baeta.io\`,
		lastName: \`Doe \${i}\`,
	}));
	return users;
});
`,
		},
		{
			relativePath: './src/modules/user-photos/user-photos.gql',
			content: `type UserPhoto {
	id: ID!
	userId: ID!
	url: String!
}

extend type User {
	photos: [UserPhoto!]
}
`,
		},
		{
			relativePath: './src/modules/user-photos/user-photos.resolvers.ts',
			content: `import { getUserPhotosModule } from './typedef.ts';

const { User } = getUserPhotosModule();

User.photos(({ root }) => {
	return Array.from({ length: 10 }).map((_, i) => ({
		id: \`u\${root.id}_p\${i}\`,
		userId: root.id,
		url: \`https://baeta.io/user/\${root.id}/photo/\${i}.png\`,
	}));
});
`,
		},
		{
			relativePath: './baeta.ts',
			content: `import { defineConfig } from '@baeta/cli';
import { autoloadPlugin } from '@baeta/plugin-autoload';

export default defineConfig({
	graphql: {
		schemas: ['src/**/*.gql'],
		contextType: 'src/types/context#Context',
		extensions: 'src/lib/extensions.ts',
	},
	compiler: {
		src: 'src/app.ts',
		dist: 'dist',
		bundleWorkspaces: true,
		esbuild: {
			format: 'esm',
		},
	},
	plugins: [autoloadPlugin()],
});
`,
		},
		{
			relativePath: './.gitignore',
			content: `# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# vitepress build output
**/.vitepress/dist

# vitepress cache directory
**/.vitepress/cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*
`,
		},
	];
}

function makePackageJson(
	appName: string,
	runtime: JavaScriptRuntime,
	packageJson: {
		name: string;
		scripts: Record<string, string | undefined>;
		dependencies: Record<string, string | undefined>;
		devDependencies: Record<string, string | undefined>;
	},
) {
	const meta = structuredClone(packageJson);

	for (const [dep, version] of Object.entries(dependenciesVersions)) {
		if (dep in meta.dependencies) {
			meta.dependencies[dep] = version;
		} else if (dep in packageJson.devDependencies) {
			meta.devDependencies[dep] = version;
		}
	}

	if (runtime === 'node') {
		meta.devDependencies['@types/bun'] = undefined;
		meta.devDependencies['@types/deno'] = undefined;
	}

	if (runtime === 'bun') {
		meta.scripts.start = `baeta generate --watch --run='bun --watch --inspect src/app.ts'`;
		meta.devDependencies['@types/node'] = undefined;
		meta.devDependencies['@types/deno'] = undefined;
	}

	if (runtime === 'deno') {
		meta.scripts.start = `baeta generate --watch --run='deno --watch --allow-env --allow-read --allow-net src/app.ts'`;
		meta.devDependencies['@types/node'] = undefined;
		meta.devDependencies['@types/bun'] = undefined;
	}

	meta.name = appName;

	return {
		relativePath: './package.json',
		content: JSON.stringify(meta, null, 2),
	};
}
