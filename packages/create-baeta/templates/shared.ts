import tsconfig from '../../../tools/tsconfig/tsconfig.json';
import type { JavaScriptRuntime } from '../lib/constants.ts';
import type { TemplateFile } from '../lib/template-file.ts';
import dependenciesVersions from '../versions.json';

export type PackageJson = {
	name: string;
	scripts: Record<string, string | undefined>;
	dependencies: Record<string, string | undefined>;
	devDependencies: Record<string, string | undefined>;
};

export function makeSharedTemplate(
	appName: string,
	runtime: JavaScriptRuntime,
	packageJson: PackageJson,
): TemplateFile[] {
	return [
		makePackageJson(appName, runtime, packageJson),
		{
			relativePath: './tsconfig.json',
			content: JSON.stringify(
				{
					...tsconfig,
					compilerOptions: {
						...tsconfig.compilerOptions,
						rootDir: 'src',
						outDir: 'dist',
						noEmit: true,
						emitDeclarationOnly: false,
					},
					exclude: ['baeta.ts'],
				},
				null,
				2,
			),
		},
		{
			relativePath: './src/modules/extensions.ts',
			content: `import { createExtensions } from '@baeta/core';
import { complexityExtension } from '@baeta/extension-complexity';
import type { Context } from '../types/context.ts';

const complexity = complexityExtension<Context>({
	defaultComplexity: 1,
	defaultListMultiplier: 10,
	async limit(ctx) {
		return {
			depth: 10,
			breadth: 50,
			complexity: 1000,
		};
	},
});

export default createExtensions({
	complexityExtension: complexity
});
`,
		},
		{
			relativePath: './src/modules/user/user.gql',
			content: `type User {
	id: ID!
	email: String!
	lastName: String!
	profile: String
	givenName: String
}

input UserWhereUniqueInput {
	id: ID!
}

type Query {
	user(where: UserWhereUniqueInput!): User
	users: [User!]
}
`,
		},
		{
			relativePath: './src/modules/user/index.ts',
			content: `import { UserModule } from './typedef.ts';

const { Query, User } = UserModule;

const userQuery = Query.user
	.use(async (next, { args }) => {
		const result = await next();
		console.log('Got user:', result, 'for args:', args);
		return result;
	})
	.resolve(({ args }) => {
		return {
			id: args.where.id,
			email: 'jon.doe@baeta.io',
			lastName: 'Doe',
			givenName: null,
			profile: null,
		};
	});

const usersQuery = Query.users.resolve(() => {
	const users = Array.from({ length: 10 }).map((_, i) => ({
		id: i.toString(),
		email: \`jon.doe\${i}@baeta.io\`,
		lastName: \`Doe \${i}\`,
		givenName: null,
		profile: null,
	}));
	return users;
});

export default UserModule.$schema({
	User: User.$fields({
		id: User.id.key('id'),
		email: User.email.key('email'),
		lastName: User.lastName.key('lastName'),
		givenName: User.givenName.key('givenName').undefinedAsNull(),
		profile: User.profile.key('profile').undefinedAsNull(),
	}),
	Query: Query.$fields({
		user: userQuery,
		users: usersQuery,
	}),
});
`,
		},
		{
			relativePath: './src/modules/user-photos/user-photos.gql',
			content: `type UserPhoto {
	id: ID!
	userId: ID!
	url: String!
}

extend type User {
	photos: [UserPhoto!]
}
`,
		},
		{
			relativePath: './src/modules/user-photos/index.ts',
			content: `import { UserPhotosModule } from './typedef.ts';

const { User, UserPhoto } = UserPhotosModule;

export default UserPhotosModule.$schema({
	User: User.$fields({
		photos: User.photos.resolve(({ source }) => {
			return Array.from({ length: 10 }).map((_, i) => ({
				id: \`u\${source.id}_p\${i}\`,
				userId: source.id,
				url: \`https://baeta.io/user/\${source.id}/photo/\${i}.png\`,
			}));
		}),
	}),
	UserPhoto: UserPhoto.$fields({
		id: UserPhoto.id.key('id'),
		url: UserPhoto.url.key('url'),
		userId: UserPhoto.userId.key('userId'),
	}),
});
`,
		},
		{
			relativePath: './src/modules/types.ts',
			content: `import type { GraphQLResolveInfo } from 'graphql';
import type { BaseObjectTypes, BaseScalars } from '../__generated__/utility.ts';
import type { Context } from '../types/context.ts';

export interface Scalars extends BaseScalars {}

export interface ObjectTypes extends BaseObjectTypes {
	User: {
		id: string;
		email: string;
		lastName: string;
		givenName?: string | null;
		profile?: string | null;
	};
}

export type Ctx = Context;

export type Info = GraphQLResolveInfo;
`,
		},
		{
			relativePath: './baeta.ts',
			content: `import { defineConfig } from '@baeta/cli';

export default defineConfig({
	graphql: {
		schemas: ['src/**/*.gql'],
	},
});
`,
		},
		{
			relativePath: './.gitignore',
			content: `# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# vitepress build output
**/.vitepress/dist

# vitepress cache directory
**/.vitepress/cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*
`,
		},
	];
}

function makePackageJson(
	appName: string,
	runtime: JavaScriptRuntime,
	packageJson: {
		name: string;
		scripts: Record<string, string | undefined>;
		dependencies: Record<string, string | undefined>;
		devDependencies: Record<string, string | undefined>;
	},
) {
	const meta = structuredClone(packageJson);

	for (const [dep, version] of Object.entries(dependenciesVersions)) {
		if (dep in meta.dependencies) {
			meta.dependencies[dep] = version;
		} else if (dep in packageJson.devDependencies) {
			meta.devDependencies[dep] = version;
		}
	}

	if (runtime === 'node') {
		meta.devDependencies['@types/bun'] = undefined;
		meta.devDependencies['@types/deno'] = undefined;
	}

	if (runtime === 'bun') {
		meta.scripts.start = `baeta generate --watch --run='bun --watch --inspect src/app.ts'`;
		meta.devDependencies['@types/node'] = undefined;
		meta.devDependencies['@types/deno'] = undefined;
	}

	if (runtime === 'deno') {
		meta.scripts.start = `baeta generate --watch --run='deno --watch --allow-env --allow-read --allow-net src/app.ts'`;
		meta.devDependencies['@types/node'] = undefined;
		meta.devDependencies['@types/bun'] = undefined;
	}

	meta.name = appName;

	return {
		relativePath: './package.json',
		content: JSON.stringify(meta, null, 2),
	};
}
