"use strict";(self.webpackChunk_baeta_website=self.webpackChunk_baeta_website||[]).push([["8147"],{29005:function(e,n,r){r.r(n),r.d(n,{frontMatter:()=>a,default:()=>h,toc:()=>d,metadata:()=>t,assets:()=>l,contentTitle:()=>o});var t=JSON.parse('{"id":"intro","title":"Introduction","description":"Building GraphQL APIs shouldn\'t be complicated. Baeta helps developers focus on what matters most - creating powerful, scalable APIs without the boilerplate.","source":"@site/docs/intro.mdx","sourceDirName":".","slug":"/intro","permalink":"/docs/intro","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"defaultSidebar","next":{"title":"Getting Started","permalink":"/docs/category/getting-started"}}'),s=r(92669),i=r(51846);let a={sidebar_position:1},o="Introduction",l={},d=[{value:"What is Baeta?",id:"what-is-baeta",level:2},{value:"Key Features",id:"key-features",level:3},{value:"And optional extensions and plugins",id:"and-optional-extensions-and-plugins",level:4},{value:"Why use Baeta?",id:"why-use-baeta",level:2},{value:"How it Works",id:"how-it-works",level:2},{value:"1. Define your schema",id:"1-define-your-schema",level:4},{value:"2. Implement your resolvers",id:"2-implement-your-resolvers",level:4},{value:"3. Add authorization",id:"3-add-authorization",level:4},{value:"4. Add caching",id:"4-add-caching",level:4},{value:"Compatibility",id:"compatibility",level:2},{value:"Ready to get started?",id:"ready-to-get-started",level:2}];function c(e){let n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"introduction",children:"Introduction"})}),"\n",(0,s.jsxs)(n.p,{children:["Building GraphQL APIs shouldn't be complicated. ",(0,s.jsx)(n.strong,{children:"Baeta"})," helps developers focus on what matters most - creating powerful, scalable APIs without the boilerplate."]}),"\n",(0,s.jsx)(n.h2,{id:"what-is-baeta",children:"What is Baeta?"}),"\n",(0,s.jsx)(n.p,{children:"Baeta is a modern, modular, open-source GraphQL framework designed with flexibility in mind. It follows a granular approach where you only add what you need. Starting with a powerful core for building GraphQL APIs, you can progressively add features through official extensions based on your requirements"}),"\n",(0,s.jsx)(n.h3,{id:"key-features",children:"Key Features"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Modular Architecture"}),": Organize your API into manageable modules"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Schema-First Development"}),": Define your API contract upfront"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Type Safety"}),": Automatic code generation for type-safe development"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Middleware & Directives"}),": Easy integration of custom behaviors"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"High Performance"}),": Built for scalability and efficiency"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"and-optional-extensions-and-plugins",children:"And optional extensions and plugins"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"@baeta/extension-auth"}),": Add powerful scope-based authorization"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"@baeta/extension-cache"}),": Implement automatic caching with simple update patterns"]}),"\n",(0,s.jsx)(n.li,{children:"... and more!"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"why-use-baeta",children:"Why use Baeta?"}),"\n",(0,s.jsx)(n.p,{children:"Baeta makes it easy to build better GraphQL APIs while staying flexible. Here's how:"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Granular and Progressive:"})," Start small and add features as you need them. Whether you're building a simple API or a complex system, Baeta scales with your needs."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Modular architecture:"})," Baeta's modular design allows you to organize your GraphQL API into smaller, more manageable modules that can be added or removed as needed. This makes it easier to maintain and scale your API over time."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Schema-first approach:"})," With Baeta, you define your schema first, and then logic and resolvers. This approach ensures a consistent and well-defined API for your clients and reduces boilerplate code."]}),"\n",(0,s.jsx)(n.h2,{id:"how-it-works",children:"How it Works"}),"\n",(0,s.jsx)(n.h4,{id:"1-define-your-schema",children:"1. Define your schema"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",children:"type User {\n  id: ID!\n  name: String!\n  email: String!\n  age: Int\n}\n\ninput UserWhereUnique {\n  id: ID\n  email: String\n}\n\ntype Query {\n  user(where: UserWhereUnique!): User!\n  users: [User!]!\n}\n"})}),"\n",(0,s.jsx)(n.h4,{id:"2-implement-your-resolvers",children:"2. Implement your resolvers"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'import { getUserModule } from "./typedef";\n\nconst { Query } = getUserModule();\n\nQuery.user(({ args }) => {\n  return dataSource.user.find(args.where);\n});\n\nQuery.users(() => {\n  return dataSource.user.findMany();\n});\n'})}),"\n",(0,s.jsx)(n.h4,{id:"3-add-authorization",children:"3. Add authorization"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const { Query, Mutation } = getUserModule();\n\nQuery.users.$auth({\n  $or: {\n    isPublic: true,\n    isLoggedIn: true,\n  },\n});\n"})}),"\n",(0,s.jsx)(n.h4,{id:"4-add-caching",children:"4. Add caching"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'import { getUserModule } from "./typedef";\n\nconst { User, Query } = getUserModule();\n\nexport const userCache = User.$createCache();\n\nQuery.user.$useCache(userCache);\nQuery.users.$useCache(userCache);\n'})}),"\n",(0,s.jsx)(n.h2,{id:"compatibility",children:"Compatibility"}),"\n",(0,s.jsxs)(n.p,{children:["Baeta is compatible with all GraphQL servers, which makes it easy to integrate with your existing stack. It works seamlessly with popular GraphQL server libraries such as ",(0,s.jsx)(n.strong,{children:"Graphql Yoga"})," and ",(0,s.jsx)(n.strong,{children:"Apollo Server"}),", as well as other popular tools like ",(0,s.jsx)(n.strong,{children:"Prisma"}),", ",(0,s.jsx)(n.strong,{children:"Drizzle"})," and ",(0,s.jsx)(n.strong,{children:"Kysely"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Baeta's development tools are built for Node.js, but the runtime code is environment-agnostic. This means your Baeta applications can run anywhere JavaScript runs, including:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Deno"}),"\n",(0,s.jsx)(n.li,{children:"Cloudflare Workers"}),"\n",(0,s.jsx)(n.li,{children:"AWS Lambda"}),"\n",(0,s.jsx)(n.li,{children:"Vercel Edge Functions"}),"\n",(0,s.jsx)(n.li,{children:"Bun"}),"\n",(0,s.jsx)(n.li,{children:"Node.js"}),"\n",(0,s.jsx)(n.li,{children:"Any other JavaScript runtime"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"ready-to-get-started",children:"Ready to get started?"}),"\n",(0,s.jsx)(n.p,{children:"Head over to the the next page to learn more and to get started!"})]})}function h(e={}){let{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},51846:function(e,n,r){r.d(n,{Z:()=>o,a:()=>a});var t=r(60650);let s={},i=t.createContext(s);function a(e){let n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);