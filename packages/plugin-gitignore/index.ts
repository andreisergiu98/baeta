import { relative, resolve } from 'node:path';
import { FileBlock, createPluginV1 } from '@baeta/generator-sdk';

/**
 * Configuration options for the gitignore plugin.
 */
export interface GitignoreOptions {
	/**
	 * Array of file tags to exclude from .gitignore.
	 * File tags are identifiers assigned to generated files
	 * to categorize them by their plugin or purpose.
	 */
	ignoreTags?: string[];
}
export interface GitignoreOptions {
	ignoreTags?: string[];
}

const defaultIgnoredTags = ['cloudflare'];

/**
 * A plugin that adds .gitignore entries for generated files.
 *
 * @param options - Plugin configuration options
 * @returns A Baeta generator plugin
 */
export function gitignorePlugin(options?: GitignoreOptions) {
	return createPluginV1({
		name: 'gitignore-plugin',
		actionName: 'add  generated files to .gitignore',
		generate: async (ctx, next) => {
			await next();

			const ignoredTags = [...(options?.ignoreTags ?? []), ...defaultIgnoredTags];

			const modulesDir = ctx.generatorOptions.modulesDir;
			const moduleDefinitionName = ctx.generatorOptions.moduleDefinitionName;

			const filePaths = ctx.fileManager.files
				.filter((file) => {
					return !file.filename.endsWith(moduleDefinitionName) && !ignoredTags.includes(file.tag);
				})
				.map((file) => file.filename);

			const generatedPaths = filePaths
				.map((file) => relative(ctx.generatorOptions.cwd, file))
				.filter((file) => !file.endsWith(moduleDefinitionName));

			generatedPaths.push(
				`${relative(ctx.generatorOptions.cwd, modulesDir)}/**/${moduleDefinitionName}`,
			);

			generatedPaths.sort((a, b) => a.localeCompare(b));

			const gitignoreStart = '# Generated by Baeta - Begin';
			const gitignoreInner = generatedPaths.join('\n');
			const gitignoreEnd = '# Generated by Baeta - End';

			const file = new FileBlock(
				resolve(ctx.generatorOptions.cwd, '.gitignore'),
				gitignoreInner,
				gitignoreStart,
				gitignoreEnd,
				'gitignore',
			);

			ctx.fileManager.add(file);
		},
	});
}
