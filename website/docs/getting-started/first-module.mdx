---
sidebar_position: 3
description: ''
---

# First module

Baeta is a schema-first and modular framework, where each module has its own schema definitions and resolvers.
In this guide, we will cover how to create your first module and extend it with another module.

### Create module schema

A module can have multiple schema files, so there are many ways to organize it.
One way is to separate files for types, inputs, and operations.

Let's start with a simple schema file for our user module at `src/modules/user/user.gql`:

```graphql
type User {
  id: ID!
  name: String!
}

type Query {
  user(id: ID): User
}
```

### Generate types

After creating the schema, we need to generate the type definitions for the module.
We can do this with the following command:

```bash
yarn generate
# or
yarn baeta generate
```

This command will generate an autogenerated file `src/modules/user/typedef.ts` that contains the type definitions of the module.

:::note
Baeta can watch for changes with the `--watch` flag.
:::

### Add resolver

Now we can add a resolver for the `user` query field in `src/modules/user/resolvers.ts`:

```typescript
import { getUserModule } from './typedef';

const { Query } = getUserModule();

Query.user(async (params) => {
  return {
    id: params.args.id ?? 'id',
    name: 'John Doe',
  };
});
```

We import the `getUserModule` function from our autogenerated `typedef.ts` file, and use it to access the `Query` type.
We then add a resolver for the `user` field that returns a hardcoded `user` object with an `id` and `name`.

### Exporting the module and registering resolvers

Next, we need to export the module and register its resolvers in `src/modules/user/index.ts`:

```typescript
import './resolvers';
import { getUserModule } from './typedef';

export const userModule = getUserModule();
```
